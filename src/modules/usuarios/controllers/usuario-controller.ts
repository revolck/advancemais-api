import { Request, Response } from "express";
import bcrypt from "bcrypt";
import { prisma } from "../../../config/prisma";
import { generateTokenPair } from "../utils/auth";
import { invalidateUserCache } from "../utils/cache";
import { logger } from "../../../utils/logger";

/**
 * Controllers para autentica√ß√£o e gest√£o de usu√°rios
 * Implementa padr√µes de microservi√ßos com verifica√ß√£o de email obrigat√≥ria
 *
 * Responsabilidades:
 * - Autentica√ß√£o de usu√°rios com verifica√ß√£o de email
 * - Gest√£o de sess√µes e tokens
 * - Valida√ß√£o de credenciais
 * - Rate limiting integrado
 *
 * Caracter√≠sticas:
 * - Verifica√ß√£o de email obrigat√≥ria para login
 * - Valida√ß√£o rigorosa de dados
 * - Logs estruturados para observabilidade
 * - Tratamento robusto de erros
 * - Compatibilidade com Supabase Auth
 *
 * @author Sistema Advance+
 * @version 6.0.0 - Sistema completo com verifica√ß√£o de email
 */

/**
 * Interface para dados de login
 */
interface LoginData {
  documento: string; // CPF
  senha: string;
}

const createControllerLogger = (req: Request, action: string) =>
  logger.child({
    controller: "UsuarioController",
    action,
    correlationId: req.id,
  });

/**
 * Controller para autentica√ß√£o de usu√°rios
 * Valida credenciais e verifica se email foi confirmado
 * @param req - Request object com credenciais
 * @param res - Response object
 */
export const loginUsuario = async (req: Request, res: Response) => {
  const log = createControllerLogger(req, "loginUsuario");
  const correlationId = req.id;
  const startTime = Date.now();

  try {
    log.info("üîê Iniciando processo de login");

    const { documento, senha }: LoginData = req.body;

    // Valida√ß√£o b√°sica de entrada
    if (!documento || !senha) {
      log.warn("‚ö†Ô∏è Dados de login incompletos");
      return res.status(400).json({
        success: false,
        message: "Documento e senha s√£o obrigat√≥rios",
        correlationId,
      });
    }

    // Remove caracteres especiais do documento para compara√ß√£o
    const documentoLimpo = documento.replace(/\D/g, "");

    if (documentoLimpo.length !== 11) {
      log.warn(
        { length: documentoLimpo.length },
        "‚ö†Ô∏è CPF inv√°lido informado"
      );
      return res.status(400).json({
        success: false,
        message: "Documento deve ser um CPF v√°lido com 11 d√≠gitos",
        correlationId,
      });
    }

    log.info(
      { documentoPrefix: documentoLimpo.substring(0, 3) },
      "üîç Buscando usu√°rio por CPF"
    );

    // Busca usu√°rio no banco com todos os campos necess√°rios
    const usuario = await prisma.usuario.findUnique({
      where: { cpf: documentoLimpo },
      select: {
        id: true,
        email: true,
        senha: true,
        nomeCompleto: true,
        role: true,
        status: true,
        tipoUsuario: true,
        supabaseId: true,
        emailVerificado: true, // CAMPO CR√çTICO PARA VERIFICA√á√ÉO
        emailVerificadoEm: true,
        ultimoLogin: true,
        criadoEm: true,
      },
    });

    if (!usuario) {
      log.warn(
        { documentoPrefix: documentoLimpo.substring(0, 3) },
        "‚ö†Ô∏è Usu√°rio n√£o encontrado"
      );
      return res.status(401).json({
        success: false,
        message: "Credenciais inv√°lidas",
        correlationId,
      });
    }

    log.info(
      { userId: usuario.id, email: usuario.email },
      "üë§ Usu√°rio encontrado"
    );

    // Verifica status da conta
    if (usuario.status !== "ATIVO") {
      log.warn(
        { userId: usuario.id, status: usuario.status },
        "‚ö†Ô∏è Conta inativa"
      );
      return res.status(403).json({
        success: false,
        message: `Conta ${usuario.status.toLowerCase()}. Entre em contato com o suporte.`,
        code: "ACCOUNT_INACTIVE",
        status: usuario.status,
        correlationId,
      });
    }

    // VERIFICA√á√ÉO CR√çTICA: Email deve estar verificado
    if (!usuario.emailVerificado) {
      log.warn(
        { userId: usuario.id, email: usuario.email },
        "‚ö†Ô∏è Email n√£o verificado"
      );

      // Calcula h√° quanto tempo a conta foi criada
      const accountAge = Date.now() - usuario.criadoEm.getTime();
      const accountAgeDays = Math.floor(accountAge / (1000 * 60 * 60 * 24));

      return res.status(403).json({
        success: false,
        message:
          "Email n√£o verificado. Verifique sua caixa de entrada ou solicite um novo email de verifica√ß√£o.",
        code: "EMAIL_NOT_VERIFIED",
        data: {
          email: usuario.email,
          canResendVerification: true,
          accountCreated: usuario.criadoEm,
          accountAgeDays,
          helpText:
            accountAgeDays > 1
              ? "Sua conta foi criada h√° mais de 1 dia. Verifique sua pasta de spam ou solicite um novo email."
              : "Verifique sua caixa de entrada. O email pode demorar alguns minutos para chegar.",
        },
        correlationId,
      });
    }

    log.info(
      { userId: usuario.id, verifiedAt: usuario.emailVerificadoEm },
      "‚úÖ Email verificado"
    );

    // Valida senha usando bcrypt
    log.info({ userId: usuario.id }, "üîê Validando senha");
    const senhaValida = await bcrypt.compare(senha, usuario.senha);

    if (!senhaValida) {
      log.warn({ userId: usuario.id }, "‚ö†Ô∏è Senha inv√°lida");
      return res.status(401).json({
        success: false,
        message: "Credenciais inv√°lidas",
        correlationId,
      });
    }

    // Gera tokens de acesso e refresh
    const tokens = generateTokenPair(usuario.id, usuario.role);

    // Atualiza √∫ltimo login e armazena refresh token
    log.info({ userId: usuario.id }, "üíæ Atualizando √∫ltimo login");
    await prisma.usuario.update({
      where: { id: usuario.id },
      data: {
        ultimoLogin: new Date(),
        refreshToken: tokens.refreshToken,
        atualizadoEm: new Date(),
      },
    });

    await invalidateUserCache(usuario);

    const duration = Date.now() - startTime;
    log.info(
      { duration, userId: usuario.id, email: usuario.email },
      "‚úÖ Login realizado com sucesso"
    );

    // Prepara dados de resposta (sem informa√ß√µes sens√≠veis)
    const responseData = {
      id: usuario.id,
      email: usuario.email,
      nomeCompleto: usuario.nomeCompleto,
      role: usuario.role,
      tipoUsuario: usuario.tipoUsuario,
      supabaseId: usuario.supabaseId,
      emailVerificado: usuario.emailVerificado,
      emailVerificadoEm: usuario.emailVerificadoEm,
      ultimoLogin: new Date().toISOString(),
    };

    // Retorna dados do usu√°rio autenticado com tokens
    res.json({
      success: true,
      message: "Login realizado com sucesso",
      usuario: responseData,
      token: tokens.accessToken,
      refreshToken: tokens.refreshToken,
      tokenType: tokens.tokenType,
      expiresIn: tokens.expiresIn,
      correlationId,
      timestamp: new Date().toISOString(),
    });
  } catch (error) {
    const duration = Date.now() - startTime;
    const errorMessage =
      error instanceof Error ? error.message : "Erro desconhecido";
    const err =
      error instanceof Error ? error : new Error(String(error));

    log.error(
      {
        err,
        duration,
        documento: req.body.documento
          ? `${req.body.documento.substring(0, 3)}***`
          : "n√£o fornecido",
      },
      "‚ùå Erro cr√≠tico no login"
    );

    // Resposta de erro sem vazar informa√ß√µes sens√≠veis
    res.status(500).json({
      success: false,
      message: "Erro interno do servidor",
      correlationId,
      timestamp: new Date().toISOString(),
      // Em desenvolvimento, inclui mais detalhes
      ...(process.env.NODE_ENV === "development" && {
        error: errorMessage,
      }),
    });
  }
};

/**
 * Controller para logout de usu√°rios
 * Remove refresh token do banco de dados
 * @param req - Request object com dados do usu√°rio autenticado
 * @param res - Response object
 */
export const logoutUsuario = async (req: Request, res: Response) => {
  const log = createControllerLogger(req, "logoutUsuario");
  const correlationId = req.id;

  try {
    const userId = req.user?.id;

    if (!userId) {
      log.warn("‚ö†Ô∏è Tentativa de logout sem usu√°rio autenticado");
      return res.status(401).json({
        success: false,
        message: "Usu√°rio n√£o autenticado",
        correlationId,
      });
    }

    log.info({ userId }, "üö™ Iniciando logout");

    // Remove refresh token do banco (invalida√ß√£o de sess√£o)
    await prisma.usuario.update({
      where: { id: userId },
      data: {
        refreshToken: null,
        atualizadoEm: new Date(),
      },
    });

    await invalidateUserCache({ id: userId });

    log.info({ userId }, "‚úÖ Logout realizado com sucesso");

    res.json({
      success: true,
      message: "Logout realizado com sucesso",
      correlationId,
      timestamp: new Date().toISOString(),
    });
  } catch (error) {
    const errorMessage =
      error instanceof Error ? error.message : "Erro desconhecido";
    const err = error instanceof Error ? error : new Error(String(error));

    log.error({ err, userId: req.user?.id }, "‚ùå Erro no logout");

    res.status(500).json({
      success: false,
      message: "Erro interno do servidor",
      correlationId,
      timestamp: new Date().toISOString(),
      ...(process.env.NODE_ENV === "development" && {
        error: errorMessage,
      }),
    });
  }
};

/**
 * Controller para renova√ß√£o de tokens
 * Valida refresh token e gera novos tokens de acesso
 * @param req - Request object com refresh token
 * @param res - Response object
 */
export const refreshToken = async (req: Request, res: Response) => {
  const log = createControllerLogger(req, "refreshToken");
  const correlationId = req.id;

  try {
    const { refreshToken } = req.body;

    if (!refreshToken) {
      log.warn("‚ö†Ô∏è Refresh token n√£o fornecido");
      return res.status(400).json({
        success: false,
        message: "Refresh token √© obrigat√≥rio",
        correlationId,
      });
    }

    log.info(
      { tokenPrefix: refreshToken.substring(0, 10) },
      "üîÑ Validando refresh token"
    );

    // Busca usu√°rio pelo refresh token
    const usuario = await prisma.usuario.findFirst({
      where: { refreshToken },
      select: {
        id: true,
        email: true,
        nomeCompleto: true,
        role: true,
        status: true,
        tipoUsuario: true,
        supabaseId: true,
        emailVerificado: true,
        ultimoLogin: true,
      },
    });

    if (!usuario) {
      log.warn("‚ö†Ô∏è Refresh token inv√°lido ou n√£o encontrado");
      return res.status(401).json({
        success: false,
        message: "Refresh token inv√°lido",
        code: "INVALID_REFRESH_TOKEN",
        correlationId,
      });
    }

    log.info(
      { userId: usuario.id, email: usuario.email },
      "üë§ Refresh token v√°lido"
    );

    // Verifica se a conta ainda est√° ativa
    if (usuario.status !== "ATIVO") {
      log.warn(
        { userId: usuario.id, status: usuario.status },
        "‚ö†Ô∏è Conta inativa durante refresh"
      );

      // Remove refresh token inv√°lido
      await prisma.usuario.update({
        where: { id: usuario.id },
        data: { refreshToken: null },
      });

      await invalidateUserCache(usuario);

      return res.status(403).json({
        success: false,
        message: `Conta ${usuario.status.toLowerCase()}`,
        code: "ACCOUNT_INACTIVE",
        status: usuario.status,
        correlationId,
      });
    }

    // Verifica se email ainda est√° verificado (caso tenha sido revertido por admin)
    if (!usuario.emailVerificado) {
      log.warn(
        { userId: usuario.id },
        "‚ö†Ô∏è Email n√£o verificado durante refresh"
      );

      // Remove refresh token
      await prisma.usuario.update({
        where: { id: usuario.id },
        data: { refreshToken: null },
      });

      await invalidateUserCache(usuario);

      return res.status(403).json({
        success: false,
        message: "Email n√£o verificado. Verifique sua caixa de entrada.",
        code: "EMAIL_NOT_VERIFIED",
        correlationId,
      });
    }

    log.info(
      { userId: usuario.id },
      "‚úÖ Refresh token validado com sucesso"
    );

    // Atualiza √∫ltimo acesso
    await prisma.usuario.update({
      where: { id: usuario.id },
      data: {
        ultimoLogin: new Date(),
        atualizadoEm: new Date(),
      },
    });

    await invalidateUserCache(usuario);

    // Prepara dados de resposta
    const responseData = {
      id: usuario.id,
      email: usuario.email,
      nomeCompleto: usuario.nomeCompleto,
      role: usuario.role,
      tipoUsuario: usuario.tipoUsuario,
      supabaseId: usuario.supabaseId,
      emailVerificado: usuario.emailVerificado,
      ultimoLogin: usuario.ultimoLogin,
    };

    res.json({
      success: true,
      message: "Token renovado com sucesso",
      usuario: responseData,
      correlationId,
      timestamp: new Date().toISOString(),
    });
  } catch (error) {
    const errorMessage =
      error instanceof Error ? error.message : "Erro desconhecido";
    const err = error instanceof Error ? error : new Error(String(error));

    log.error({ err }, "‚ùå Erro ao validar refresh token");

    res.status(500).json({
      success: false,
      message: "Erro interno do servidor",
      correlationId,
      timestamp: new Date().toISOString(),
      ...(process.env.NODE_ENV === "development" && {
        error: errorMessage,
      }),
    });
  }
};

/**
 * Controller para obter perfil do usu√°rio autenticado
 * Retorna dados completos do perfil (sem informa√ß√µes sens√≠veis)
 * @param req - Request object com dados do usu√°rio
 * @param res - Response object
 */
export const obterPerfil = async (req: Request, res: Response) => {
  const log = createControllerLogger(req, "obterPerfil");
  const correlationId = req.id;

  try {
    const userId = req.user?.id;

    if (!userId) {
      log.warn("‚ö†Ô∏è Tentativa de obter perfil sem autentica√ß√£o");
      return res.status(401).json({
        success: false,
        message: "Usu√°rio n√£o autenticado",
        correlationId,
      });
    }

    log.info({ userId }, "üë§ Obtendo perfil do usu√°rio");

    // Busca dados completos do usu√°rio (excluindo informa√ß√µes sens√≠veis)
    const usuario = await prisma.usuario.findUnique({
      where: { id: userId },
      select: {
        id: true,
        email: true,
        nomeCompleto: true,
        cpf: true,
        cnpj: true,
        telefone: true,
        dataNasc: true,
        genero: true,
        matricula: true,
        role: true,
        status: true,
        tipoUsuario: true,
        supabaseId: true,
        emailVerificado: true,
        emailVerificadoEm: true,
        ultimoLogin: true,
        criadoEm: true,
        atualizadoEm: true,
        // Relacionamentos
        empresa: {
          select: {
            id: true,
            nome: true,
          },
        },
        enderecos: {
          select: {
            id: true,
            logradouro: true,
            numero: true,
            bairro: true,
            cidade: true,
            estado: true,
            cep: true,
          },
        },
        // Estat√≠sticas de pagamentos removidas
      },
    });

    if (!usuario) {
      log.warn({ userId }, "‚ö†Ô∏è Usu√°rio n√£o encontrado ao obter perfil");
      return res.status(404).json({
        success: false,
        message: "Usu√°rio n√£o encontrado",
        correlationId,
      });
    }

    log.info(
      { userId: usuario.id, email: usuario.email },
      "‚úÖ Perfil obtido com sucesso"
    );

    // Prepara estat√≠sticas adicionais
    const profileStats = {
      accountAge: Math.floor(
        (Date.now() - usuario.criadoEm.getTime()) / (1000 * 60 * 60 * 24)
      ),
      hasCompletedProfile: !!(usuario.telefone && usuario.nomeCompleto),
      hasAddress: usuario.enderecos.length > 0,
      totalOrders: 0,
      totalSubscriptions: 0,
      emailVerificationStatus: {
        verified: usuario.emailVerificado,
        verifiedAt: usuario.emailVerificadoEm,
      },
    };

    // Retorna perfil completo
    res.json({
      success: true,
      message: "Perfil obtido com sucesso",
      usuario: {
        ...usuario,
        _count: undefined, // Remove contadores internos da resposta
      },
      stats: profileStats,
      correlationId,
      timestamp: new Date().toISOString(),
    });
  } catch (error) {
    const errorMessage =
      error instanceof Error ? error.message : "Erro desconhecido";
    const err = error instanceof Error ? error : new Error(String(error));

    log.error({ err, userId: req.user?.id }, "‚ùå Erro ao obter perfil");

    res.status(500).json({
      success: false,
      message: "Erro interno do servidor",
      correlationId,
      timestamp: new Date().toISOString(),
      ...(process.env.NODE_ENV === "development" && {
        error: errorMessage,
      }),
    });
  }
};

/**
 * Estat√≠sticas de uso dos controllers (para monitoramento)
 */
export const getControllerStats = () => {
  return {
    module: "usuario-controller",
    version: "6.0.0",
    features: {
      emailVerificationRequired: true,
      rateLimitingIntegrated: true,
      correlationIdTracking: true,
      securePasswordHandling: true,
    },
    endpoints: {
      loginUsuario: "POST /login",
      logoutUsuario: "POST /logout",
      refreshToken: "POST /refresh",
      obterPerfil: "GET /perfil",
    },
    lastUpdated: "2025-08-04T18:00:00Z",
  };
};
