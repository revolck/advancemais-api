import * as Brevo from '@getbrevo/brevo';
import { BrevoClient } from '../client/brevo-client';
import { BrevoConfigManager } from '../config/brevo-config';

/**
 * Servi√ßo de SMS simplificado para uso futuro
 * Preparado para integra√ß√£o com Brevo SMS API
 */
export interface SMSResult {
  success: boolean;
  messageId?: string;
  error?: string;
  simulated?: boolean;
}

export interface SMSData {
  to: string;
  message: string;
  sender?: string;
}

export class SMSService {
  private client: BrevoClient;
  private config: BrevoConfigManager;

  constructor() {
    this.client = BrevoClient.getInstance();
    this.config = BrevoConfigManager.getInstance();
  }

  /**
   * Envia SMS de forma robusta
   */
  public async sendSMS(smsData: SMSData): Promise<SMSResult> {
    const correlationId = this.generateCorrelationId();

    try {
      console.log(`üì± [${correlationId}] Enviando SMS para: ${smsData.to}`);

      // Valida√ß√£o b√°sica
      if (!this.isValidSMSData(smsData)) {
        throw new Error('Dados do SMS inv√°lidos');
      }

      // Normaliza n√∫mero de telefone
      const normalizedPhone = this.normalizePhoneNumber(smsData.to);

      // Executa envio
      const result = await this.performSMSSend(
        {
          ...smsData,
          to: normalizedPhone,
        },
        correlationId,
      );

      // Registra resultado
      if (result.success) {
        await this.logSMSSuccess(smsData, result.messageId, correlationId);
        console.log(`‚úÖ [${correlationId}] SMS enviado com sucesso`);
      } else {
        await this.logSMSError(smsData, result.error || 'Erro desconhecido', correlationId);
      }

      return result;
    } catch (error) {
      const errorMsg = error instanceof Error ? error.message : 'Erro desconhecido';
      console.error(`‚ùå [${correlationId}] Erro no envio de SMS:`, errorMsg);

      await this.logSMSError(smsData, errorMsg, correlationId);
      return { success: false, error: errorMsg };
    }
  }

  /**
   * Envia SMS de verifica√ß√£o/autentica√ß√£o
   */
  public async sendVerificationSMS(phoneNumber: string, code: string): Promise<SMSResult> {
    const message = `Seu c√≥digo de verifica√ß√£o Advance+: ${code}. V√°lido por 10 minutos. N√£o compartilhe este c√≥digo.`;

    return await this.sendSMS({
      to: phoneNumber,
      message,
      sender: 'Advance+',
    });
  }

  /**
   * Envia SMS de notifica√ß√£o
   */
  public async sendNotificationSMS(phoneNumber: string, message: string): Promise<SMSResult> {
    return await this.sendSMS({
      to: phoneNumber,
      message: `Advance+: ${message}`,
      sender: 'Advance+',
    });
  }

  /**
   * Health check do servi√ßo
   */
  public async checkHealth(): Promise<boolean> {
    try {
      // Se estiver em modo simulado, sempre retorna true
      if (this.client.isSimulated()) {
        return true;
      }

      // Testa conectividade com API Brevo
      return await this.client.healthCheck();
    } catch (error) {
      console.warn('‚ö†Ô∏è SMS Health check falhou:', error);
      return false;
    }
  }

  // ===========================
  // M√âTODOS PRIVADOS
  // ===========================

  /**
   * Executa envio do SMS
   */
  private async performSMSSend(smsData: SMSData, correlationId: string): Promise<SMSResult> {
    // Modo simulado (desenvolvimento ou API n√£o configurada)
    if (this.client.isSimulated()) {
      console.log(`üé≠ [${correlationId}] SMS simulado para: ${smsData.to}`);
      console.log(`üìÑ [${correlationId}] Mensagem: ${smsData.message}`);
      return {
        success: true,
        messageId: `sms_sim_${Date.now()}`,
        simulated: true,
      };
    }

    // Tentativa de envio real
    try {
      const smsAPI = this.client.getSMSAPI();

      if (!smsAPI) {
        throw new Error('API de SMS n√£o dispon√≠vel');
      }

      const sendSmsRequest = new Brevo.SendTransacSms();
      sendSmsRequest.type = Brevo.SendTransacSms.TypeEnum.Transactional;
      sendSmsRequest.unicodeEnabled = false;
      sendSmsRequest.sender = smsData.sender || 'Advance+';
      sendSmsRequest.recipient = smsData.to;
      sendSmsRequest.content = smsData.message;

      console.log(`üì± [${correlationId}] Enviando SMS via Brevo...`);

      // Chama API do Brevo
      const response = await smsAPI.sendTransacSms(sendSmsRequest);
      const messageId = this.extractMessageId(response);

      console.log(`‚úÖ [${correlationId}] SMS enviado via Brevo:`, {
        to: smsData.to,
        messageId,
      });

      return {
        success: true,
        messageId,
      };
    } catch (error) {
      console.error(`‚ùå [${correlationId}] Erro no envio via Brevo:`, error);

      // Fallback para simula√ß√£o em caso de erro
      console.log(`üé≠ [${correlationId}] Fallback para modo simulado`);
      return {
        success: true,
        messageId: `sms_fallback_${Date.now()}`,
        simulated: true,
        error: error instanceof Error ? error.message : 'Erro na API',
      };
    }
  }

  /**
   * Valida dados b√°sicos do SMS
   */
  private isValidSMSData(smsData: SMSData): boolean {
    return !!(
      smsData?.to &&
      smsData?.message &&
      smsData.message.length > 0 &&
      smsData.message.length <= 1600 && // Limite do Brevo
      this.isValidPhoneNumber(smsData.to)
    );
  }

  /**
   * Valida formato de n√∫mero de telefone
   */
  private isValidPhoneNumber(phone: string): boolean {
    // Valida√ß√£o b√°sica - aceita formatos internacionais
    const phoneRegex = /^\+?[1-9]\d{8,14}$/;
    const cleanPhone = phone.replace(/[\s\-\(\)]/g, '');
    return phoneRegex.test(cleanPhone);
  }

  /**
   * Normaliza n√∫mero de telefone
   */
  private normalizePhoneNumber(phone: string): string {
    // Remove espa√ßos, par√™nteses e h√≠fens
    let cleaned = phone.replace(/[\s\-\(\)]/g, '');

    // Adiciona c√≥digo do pa√≠s se n√£o tiver
    if (!cleaned.startsWith('+')) {
      if (cleaned.startsWith('55')) {
        cleaned = '+' + cleaned;
      } else if (cleaned.startsWith('0')) {
        cleaned = '+55' + cleaned.substring(1);
      } else {
        cleaned = '+55' + cleaned;
      }
    }

    return cleaned;
  }

  /**
   * Extrai message ID da resposta
   */
  private extractMessageId(response: any): string {
    if (response?.messageId) return String(response.messageId);
    if (response?.body?.messageId) return String(response.body.messageId);
    if (response?.reference) return String(response.reference);
    return `sms_brevo_${Date.now()}`;
  }

  /**
   * Registra sucesso no log
   */
  private async logSMSSuccess(
    smsData: SMSData,
    messageId?: string,
    correlationId?: string,
  ): Promise<void> {
    try {
      // Implementar log de SMS no banco se necess√°rio
      console.log(`üìä [${correlationId}] SMS enviado com sucesso:`, {
        to: smsData.to,
        messageId,
        length: smsData.message.length,
      });

      // Exemplo de como seria o log no banco (se modelo existir):
      /*
      await prisma.logSMS.create({
        data: {
          numeroTelefone: smsData.to,
          mensagem: smsData.message,
          status: "ENVIADO",
          messageId: messageId || "",
          remetente: smsData.sender || "Advance+",
        },
      });
      */
    } catch (error) {
      console.warn(`‚ö†Ô∏è [${correlationId}] Erro ao registrar log de sucesso SMS:`, error);
    }
  }

  /**
   * Registra erro no log
   */
  private async logSMSError(
    smsData: SMSData,
    error: string,
    correlationId?: string,
  ): Promise<void> {
    try {
      console.log(`üìä [${correlationId}] Erro no SMS:`, {
        to: smsData.to,
        error,
        messageLength: smsData.message.length,
      });

      // Exemplo de como seria o log no banco (se modelo existir):
      /*
      await prisma.logSMS.create({
        data: {
          numeroTelefone: smsData.to,
          mensagem: smsData.message,
          status: "FALHA",
          erro: error,
          remetente: smsData.sender || "Advance+",
        },
      });
      */
    } catch (logError) {
      console.warn(`‚ö†Ô∏è [${correlationId}] Erro ao registrar log de erro SMS:`, logError);
    }
  }

  /**
   * Gera correlation ID
   */
  private generateCorrelationId(): string {
    return `sms-${Date.now()}-${Math.random().toString(36).substr(2, 8)}`;
  }
}
