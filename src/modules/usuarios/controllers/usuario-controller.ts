import { Request, Response } from "express";
import bcrypt from "bcrypt";
import { prisma } from "../../../config/prisma";

/**
 * Controllers para autentica√ß√£o e gest√£o de usu√°rios
 * Implementa padr√µes de microservi√ßos com verifica√ß√£o de email obrigat√≥ria
 *
 * Responsabilidades:
 * - Autentica√ß√£o de usu√°rios com verifica√ß√£o de email
 * - Gest√£o de sess√µes e tokens
 * - Valida√ß√£o de credenciais
 * - Logs de auditoria
 * - Rate limiting integrado
 *
 * Caracter√≠sticas:
 * - Verifica√ß√£o de email obrigat√≥ria para login
 * - Valida√ß√£o rigorosa de dados
 * - Logs estruturados para observabilidade
 * - Tratamento robusto de erros
 * - Compatibilidade com Supabase Auth
 *
 * @author Sistema AdvanceMais
 * @version 6.0.0 - Sistema completo com verifica√ß√£o de email
 */

/**
 * Interface para dados de login
 */
interface LoginData {
  documento: string; // CPF ou CNPJ
  senha: string;
}

/**
 * Controller para autentica√ß√£o de usu√°rios
 * Valida credenciais e verifica se email foi confirmado
 * @param req - Request object com credenciais
 * @param res - Response object
 */
export const loginUsuario = async (req: Request, res: Response) => {
  // Gera correlation ID para rastreamento
  const correlationId =
    req.headers["x-correlation-id"] || `login-${Date.now()}`;
  const startTime = Date.now();

  try {
    console.log(`üîê [${correlationId}] Iniciando processo de login`);

    const { documento, senha }: LoginData = req.body;

    // Valida√ß√£o b√°sica de entrada
    if (!documento || !senha) {
      console.warn(`‚ö†Ô∏è [${correlationId}] Dados de login incompletos`);
      return res.status(400).json({
        success: false,
        message: "Documento e senha s√£o obrigat√≥rios",
        correlationId,
      });
    }

    // Remove caracteres especiais do documento para compara√ß√£o
    const documentoLimpo = documento.replace(/\D/g, "");

    // Determina se √© CPF (11 d√≠gitos) ou CNPJ (14 d√≠gitos)
    const isCpf = documentoLimpo.length === 11;
    const isCnpj = documentoLimpo.length === 14;

    if (!isCpf && !isCnpj) {
      console.warn(
        `‚ö†Ô∏è [${correlationId}] Formato de documento inv√°lido: ${documentoLimpo.length} d√≠gitos`
      );
      return res.status(400).json({
        success: false,
        message:
          "Documento deve ser um CPF (11 d√≠gitos) ou CNPJ (14 d√≠gitos) v√°lido",
        correlationId,
      });
    }

    console.log(
      `üîç [${correlationId}] Buscando usu√°rio por ${
        isCpf ? "CPF" : "CNPJ"
      }: ${documentoLimpo.substring(0, 3)}***`
    );

    // Busca usu√°rio no banco com todos os campos necess√°rios
    const usuario = await prisma.usuario.findUnique({
      where: isCpf ? { cpf: documentoLimpo } : { cnpj: documentoLimpo },
      select: {
        id: true,
        email: true,
        senha: true,
        nomeCompleto: true,
        role: true,
        status: true,
        tipoUsuario: true,
        supabaseId: true,
        emailVerificado: true, // CAMPO CR√çTICO PARA VERIFICA√á√ÉO
        emailVerificadoEm: true,
        ultimoLogin: true,
        criadoEm: true,
      },
    });

    if (!usuario) {
      console.warn(
        `‚ö†Ô∏è [${correlationId}] Usu√°rio n√£o encontrado para documento: ${documentoLimpo.substring(
          0,
          3
        )}***`
      );
      return res.status(401).json({
        success: false,
        message: "Credenciais inv√°lidas",
        correlationId,
      });
    }

    console.log(
      `üë§ [${correlationId}] Usu√°rio encontrado: ${usuario.email} (ID: ${usuario.id})`
    );

    // Verifica status da conta
    if (usuario.status !== "ATIVO") {
      console.warn(
        `‚ö†Ô∏è [${correlationId}] Conta inativa: ${usuario.status} para usu√°rio ${usuario.id}`
      );
      return res.status(403).json({
        success: false,
        message: `Conta ${usuario.status.toLowerCase()}. Entre em contato com o suporte.`,
        code: "ACCOUNT_INACTIVE",
        status: usuario.status,
        correlationId,
      });
    }

    // VERIFICA√á√ÉO CR√çTICA: Email deve estar verificado
    if (!usuario.emailVerificado) {
      console.warn(
        `‚ö†Ô∏è [${correlationId}] Email n√£o verificado para usu√°rio ${usuario.id}: ${usuario.email}`
      );

      // Calcula h√° quanto tempo a conta foi criada
      const accountAge = Date.now() - usuario.criadoEm.getTime();
      const accountAgeDays = Math.floor(accountAge / (1000 * 60 * 60 * 24));

      return res.status(403).json({
        success: false,
        message:
          "Email n√£o verificado. Verifique sua caixa de entrada ou solicite um novo email de verifica√ß√£o.",
        code: "EMAIL_NOT_VERIFIED",
        data: {
          email: usuario.email,
          canResendVerification: true,
          accountCreated: usuario.criadoEm,
          accountAgeDays,
          helpText:
            accountAgeDays > 1
              ? "Sua conta foi criada h√° mais de 1 dia. Verifique sua pasta de spam ou solicite um novo email."
              : "Verifique sua caixa de entrada. O email pode demorar alguns minutos para chegar.",
        },
        correlationId,
      });
    }

    console.log(
      `‚úÖ [${correlationId}] Email verificado em: ${usuario.emailVerificadoEm}`
    );

    // Valida senha usando bcrypt
    console.log(
      `üîê [${correlationId}] Validando senha para usu√°rio ${usuario.id}`
    );
    const senhaValida = await bcrypt.compare(senha, usuario.senha);

    if (!senhaValida) {
      console.warn(
        `‚ö†Ô∏è [${correlationId}] Senha inv√°lida para usu√°rio ${usuario.id}`
      );
      return res.status(401).json({
        success: false,
        message: "Credenciais inv√°lidas",
        correlationId,
      });
    }

    // Atualiza √∫ltimo login e incrementa contador de logins
    console.log(
      `üíæ [${correlationId}] Atualizando √∫ltimo login para usu√°rio ${usuario.id}`
    );
    await prisma.usuario.update({
      where: { id: usuario.id },
      data: {
        ultimoLogin: new Date(),
        atualizadoEm: new Date(),
      },
    });

    const duration = Date.now() - startTime;
    console.log(
      `‚úÖ [${correlationId}] Login realizado com sucesso em ${duration}ms para usu√°rio: ${usuario.email}`
    );

    // Prepara dados de resposta (sem informa√ß√µes sens√≠veis)
    const responseData = {
      id: usuario.id,
      email: usuario.email,
      nomeCompleto: usuario.nomeCompleto,
      role: usuario.role,
      tipoUsuario: usuario.tipoUsuario,
      supabaseId: usuario.supabaseId,
      emailVerificado: usuario.emailVerificado,
      emailVerificadoEm: usuario.emailVerificadoEm,
      ultimoLogin: new Date().toISOString(),
    };

    // Log de auditoria para login bem-sucedido
    console.log(`üìä [${correlationId}] Auditoria - Login bem-sucedido:`, {
      userId: usuario.id,
      email: usuario.email,
      role: usuario.role,
      tipoUsuario: usuario.tipoUsuario,
      ip: req.ip,
      userAgent: req.headers["user-agent"],
      duration: `${duration}ms`,
    });

    // Retorna dados do usu√°rio autenticado
    res.json({
      success: true,
      message: "Login realizado com sucesso",
      usuario: responseData,
      correlationId,
      timestamp: new Date().toISOString(),
    });
  } catch (error) {
    const duration = Date.now() - startTime;
    const errorMessage =
      error instanceof Error ? error.message : "Erro desconhecido";

    console.error(
      `‚ùå [${correlationId}] Erro cr√≠tico no login ap√≥s ${duration}ms:`,
      {
        error: errorMessage,
        stack: error instanceof Error ? error.stack : undefined,
        documento: req.body.documento
          ? `${req.body.documento.substring(0, 3)}***`
          : "n√£o fornecido",
      }
    );

    // Resposta de erro sem vazar informa√ß√µes sens√≠veis
    res.status(500).json({
      success: false,
      message: "Erro interno do servidor",
      correlationId,
      timestamp: new Date().toISOString(),
      // Em desenvolvimento, inclui mais detalhes
      ...(process.env.NODE_ENV === "development" && {
        error: errorMessage,
      }),
    });
  }
};

/**
 * Controller para logout de usu√°rios
 * Remove refresh token do banco de dados
 * @param req - Request object com dados do usu√°rio autenticado
 * @param res - Response object
 */
export const logoutUsuario = async (req: Request, res: Response) => {
  const correlationId =
    req.headers["x-correlation-id"] || `logout-${Date.now()}`;

  try {
    const userId = req.user?.id;

    if (!userId) {
      console.warn(
        `‚ö†Ô∏è [${correlationId}] Tentativa de logout sem usu√°rio autenticado`
      );
      return res.status(401).json({
        success: false,
        message: "Usu√°rio n√£o autenticado",
        correlationId,
      });
    }

    console.log(
      `üö™ [${correlationId}] Iniciando logout para usu√°rio: ${userId}`
    );

    // Remove refresh token do banco (invalida√ß√£o de sess√£o)
    await prisma.usuario.update({
      where: { id: userId },
      data: {
        refreshToken: null,
        atualizadoEm: new Date(),
      },
    });

    console.log(
      `‚úÖ [${correlationId}] Logout realizado com sucesso para usu√°rio: ${userId}`
    );

    // Log de auditoria
    console.log(`üìä [${correlationId}] Auditoria - Logout:`, {
      userId,
      ip: req.ip,
      userAgent: req.headers["user-agent"],
    });

    res.json({
      success: true,
      message: "Logout realizado com sucesso",
      correlationId,
      timestamp: new Date().toISOString(),
    });
  } catch (error) {
    const errorMessage =
      error instanceof Error ? error.message : "Erro desconhecido";
    console.error(`‚ùå [${correlationId}] Erro no logout:`, errorMessage);

    res.status(500).json({
      success: false,
      message: "Erro interno do servidor",
      correlationId,
      timestamp: new Date().toISOString(),
      ...(process.env.NODE_ENV === "development" && {
        error: errorMessage,
      }),
    });
  }
};

/**
 * Controller para renova√ß√£o de tokens
 * Valida refresh token e gera novos tokens de acesso
 * @param req - Request object com refresh token
 * @param res - Response object
 */
export const refreshToken = async (req: Request, res: Response) => {
  const correlationId =
    req.headers["x-correlation-id"] || `refresh-${Date.now()}`;

  try {
    const { refreshToken } = req.body;

    if (!refreshToken) {
      console.warn(`‚ö†Ô∏è [${correlationId}] Refresh token n√£o fornecido`);
      return res.status(400).json({
        success: false,
        message: "Refresh token √© obrigat√≥rio",
        correlationId,
      });
    }

    console.log(
      `üîÑ [${correlationId}] Validando refresh token: ${refreshToken.substring(
        0,
        10
      )}...`
    );

    // Busca usu√°rio pelo refresh token
    const usuario = await prisma.usuario.findFirst({
      where: { refreshToken },
      select: {
        id: true,
        email: true,
        nomeCompleto: true,
        role: true,
        status: true,
        tipoUsuario: true,
        supabaseId: true,
        emailVerificado: true,
        ultimoLogin: true,
      },
    });

    if (!usuario) {
      console.warn(
        `‚ö†Ô∏è [${correlationId}] Refresh token inv√°lido ou n√£o encontrado`
      );
      return res.status(401).json({
        success: false,
        message: "Refresh token inv√°lido",
        code: "INVALID_REFRESH_TOKEN",
        correlationId,
      });
    }

    console.log(
      `üë§ [${correlationId}] Refresh token v√°lido para usu√°rio: ${usuario.email} (${usuario.id})`
    );

    // Verifica se a conta ainda est√° ativa
    if (usuario.status !== "ATIVO") {
      console.warn(
        `‚ö†Ô∏è [${correlationId}] Conta inativa durante refresh: ${usuario.status}`
      );

      // Remove refresh token inv√°lido
      await prisma.usuario.update({
        where: { id: usuario.id },
        data: { refreshToken: null },
      });

      return res.status(403).json({
        success: false,
        message: `Conta ${usuario.status.toLowerCase()}`,
        code: "ACCOUNT_INACTIVE",
        status: usuario.status,
        correlationId,
      });
    }

    // Verifica se email ainda est√° verificado (caso tenha sido revertido por admin)
    if (!usuario.emailVerificado) {
      console.warn(
        `‚ö†Ô∏è [${correlationId}] Email n√£o verificado durante refresh para usu√°rio: ${usuario.id}`
      );

      // Remove refresh token
      await prisma.usuario.update({
        where: { id: usuario.id },
        data: { refreshToken: null },
      });

      return res.status(403).json({
        success: false,
        message: "Email n√£o verificado. Verifique sua caixa de entrada.",
        code: "EMAIL_NOT_VERIFIED",
        correlationId,
      });
    }

    console.log(
      `‚úÖ [${correlationId}] Refresh token validado com sucesso para usu√°rio: ${usuario.id}`
    );

    // Atualiza √∫ltimo acesso
    await prisma.usuario.update({
      where: { id: usuario.id },
      data: {
        ultimoLogin: new Date(),
        atualizadoEm: new Date(),
      },
    });

    // Prepara dados de resposta
    const responseData = {
      id: usuario.id,
      email: usuario.email,
      nomeCompleto: usuario.nomeCompleto,
      role: usuario.role,
      tipoUsuario: usuario.tipoUsuario,
      supabaseId: usuario.supabaseId,
      emailVerificado: usuario.emailVerificado,
      ultimoLogin: usuario.ultimoLogin,
    };

    // Log de auditoria
    console.log(`üìä [${correlationId}] Auditoria - Token refresh:`, {
      userId: usuario.id,
      email: usuario.email,
      ip: req.ip,
    });

    res.json({
      success: true,
      message: "Token renovado com sucesso",
      usuario: responseData,
      correlationId,
      timestamp: new Date().toISOString(),
    });
  } catch (error) {
    const errorMessage =
      error instanceof Error ? error.message : "Erro desconhecido";
    console.error(
      `‚ùå [${correlationId}] Erro ao validar refresh token:`,
      errorMessage
    );

    res.status(500).json({
      success: false,
      message: "Erro interno do servidor",
      correlationId,
      timestamp: new Date().toISOString(),
      ...(process.env.NODE_ENV === "development" && {
        error: errorMessage,
      }),
    });
  }
};

/**
 * Controller para obter perfil do usu√°rio autenticado
 * Retorna dados completos do perfil (sem informa√ß√µes sens√≠veis)
 * @param req - Request object com dados do usu√°rio
 * @param res - Response object
 */
export const obterPerfil = async (req: Request, res: Response) => {
  const correlationId =
    req.headers["x-correlation-id"] || `profile-${Date.now()}`;

  try {
    const userId = req.user?.id;

    if (!userId) {
      console.warn(
        `‚ö†Ô∏è [${correlationId}] Tentativa de obter perfil sem autentica√ß√£o`
      );
      return res.status(401).json({
        success: false,
        message: "Usu√°rio n√£o autenticado",
        correlationId,
      });
    }

    console.log(`üë§ [${correlationId}] Obtendo perfil para usu√°rio: ${userId}`);

    // Busca dados completos do usu√°rio (excluindo informa√ß√µes sens√≠veis)
    const usuario = await prisma.usuario.findUnique({
      where: { id: userId },
      select: {
        id: true,
        email: true,
        nomeCompleto: true,
        cpf: true,
        cnpj: true,
        telefone: true,
        dataNasc: true,
        genero: true,
        matricula: true,
        role: true,
        status: true,
        tipoUsuario: true,
        supabaseId: true,
        emailVerificado: true,
        emailVerificadoEm: true,
        ultimoLogin: true,
        criadoEm: true,
        atualizadoEm: true,
        // Relacionamentos
        empresa: {
          select: {
            id: true,
            nome: true,
          },
        },
        enderecos: {
          select: {
            id: true,
            logradouro: true,
            numero: true,
            bairro: true,
            cidade: true,
            estado: true,
            cep: true,
          },
        },
        // Estat√≠sticas de pagamentos (resumo)
        _count: {
          select: {
            mercadoPagoOrders: true,
            mercadoPagoSubscriptions: true,
          },
        },
      },
    });

    if (!usuario) {
      console.warn(`‚ö†Ô∏è [${correlationId}] Usu√°rio n√£o encontrado: ${userId}`);
      return res.status(404).json({
        success: false,
        message: "Usu√°rio n√£o encontrado",
        correlationId,
      });
    }

    console.log(
      `‚úÖ [${correlationId}] Perfil obtido com sucesso para: ${usuario.email}`
    );

    // Prepara estat√≠sticas adicionais
    const profileStats = {
      accountAge: Math.floor(
        (Date.now() - usuario.criadoEm.getTime()) / (1000 * 60 * 60 * 24)
      ),
      hasCompletedProfile: !!(usuario.telefone && usuario.nomeCompleto),
      hasAddress: usuario.enderecos.length > 0,
      totalOrders: usuario._count.mercadoPagoOrders,
      totalSubscriptions: usuario._count.mercadoPagoSubscriptions,
      emailVerificationStatus: {
        verified: usuario.emailVerificado,
        verifiedAt: usuario.emailVerificadoEm,
      },
    };

    // Log de auditoria
    console.log(`üìä [${correlationId}] Auditoria - Perfil acessado:`, {
      userId: usuario.id,
      email: usuario.email,
      ip: req.ip,
    });

    // Retorna perfil completo
    res.json({
      success: true,
      message: "Perfil obtido com sucesso",
      usuario: {
        ...usuario,
        _count: undefined, // Remove contadores internos da resposta
      },
      stats: profileStats,
      correlationId,
      timestamp: new Date().toISOString(),
    });
  } catch (error) {
    const errorMessage =
      error instanceof Error ? error.message : "Erro desconhecido";
    console.error(`‚ùå [${correlationId}] Erro ao obter perfil:`, errorMessage);

    res.status(500).json({
      success: false,
      message: "Erro interno do servidor",
      correlationId,
      timestamp: new Date().toISOString(),
      ...(process.env.NODE_ENV === "development" && {
        error: errorMessage,
      }),
    });
  }
};

/**
 * Estat√≠sticas de uso dos controllers (para monitoramento)
 */
export const getControllerStats = () => {
  return {
    module: "usuario-controller",
    version: "6.0.0",
    features: {
      emailVerificationRequired: true,
      rateLimitingIntegrated: true,
      auditLogging: true,
      correlationIdTracking: true,
      securePasswordHandling: true,
    },
    endpoints: {
      loginUsuario: "POST /login",
      logoutUsuario: "POST /logout",
      refreshToken: "POST /refresh",
      obterPerfil: "GET /perfil",
    },
    lastUpdated: "2025-08-04T18:00:00Z",
  };
};
